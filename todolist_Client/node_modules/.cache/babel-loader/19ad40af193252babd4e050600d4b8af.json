{"ast":null,"code":"'use strict';\n\nconst MongoError = require('../error').MongoError;\n/**\n * Creates a new AuthProvider, which dictates how to authenticate for a given\n * mechanism.\n * @class\n */\n\n\nclass AuthProvider {\n  constructor(bson) {\n    this.bson = bson;\n    this.authStore = [];\n  }\n  /**\n   * Authenticate\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {MongoCredentials} credentials Authentication credentials\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n\n\n  auth(sendAuthCommand, connections, credentials, callback) {\n    // Total connections\n    let count = connections.length;\n\n    if (count === 0) {\n      callback(null, null);\n      return;\n    } // Valid connections\n\n\n    let numberOfValidConnections = 0;\n    let errorObject = null;\n\n    const execute = connection => {\n      this._authenticateSingleConnection(sendAuthCommand, connection, credentials, (err, r) => {\n        // Adjust count\n        count = count - 1; // If we have an error\n\n        if (err) {\n          errorObject = new MongoError(err);\n        } else if (r && (r.$err || r.errmsg)) {\n          errorObject = new MongoError(r);\n        } else {\n          numberOfValidConnections = numberOfValidConnections + 1;\n        } // Still authenticating against other connections.\n\n\n        if (count !== 0) {\n          return;\n        } // We have authenticated all connections\n\n\n        if (numberOfValidConnections > 0) {\n          // Store the auth details\n          this.addCredentials(credentials); // Return correct authentication\n\n          callback(null, true);\n        } else {\n          if (errorObject == null) {\n            errorObject = new MongoError(`failed to authenticate using ${credentials.mechanism}`);\n          }\n\n          callback(errorObject, false);\n        }\n      });\n    };\n\n    const executeInNextTick = _connection => process.nextTick(() => execute(_connection)); // For each connection we need to authenticate\n\n\n    while (connections.length > 0) {\n      executeInNextTick(connections.shift());\n    }\n  }\n  /**\n   * Implementation of a single connection authenticating. Is meant to be overridden.\n   * Will error if called directly\n   * @ignore\n   */\n\n\n  _authenticateSingleConnection()\n  /*sendAuthCommand, connection, credentials, callback*/\n  {\n    throw new Error('_authenticateSingleConnection must be overridden');\n  }\n  /**\n   * Adds credentials to store only if it does not exist\n   * @param {MongoCredentials} credentials credentials to add to store\n   */\n\n\n  addCredentials(credentials) {\n    const found = this.authStore.some(cred => cred.equals(credentials));\n\n    if (!found) {\n      this.authStore.push(credentials);\n    }\n  }\n  /**\n   * Re authenticate pool\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n\n\n  reauthenticate(sendAuthCommand, connections, callback) {\n    const authStore = this.authStore.slice(0);\n    let count = authStore.length;\n\n    if (count === 0) {\n      return callback(null, null);\n    }\n\n    for (let i = 0; i < authStore.length; i++) {\n      this.auth(sendAuthCommand, connections, authStore[i], function (err) {\n        count = count - 1;\n\n        if (count === 0) {\n          callback(err, null);\n        }\n      });\n    }\n  }\n  /**\n   * Remove credentials that have been previously stored in the auth provider\n   * @method\n   * @param {string} source Name of database we are removing authStore details about\n   * @return {object}\n   */\n\n\n  logout(source) {\n    this.authStore = this.authStore.filter(credentials => credentials.source !== source);\n  }\n\n}\n/**\n * A function that writes authentication commands to a specific connection\n * @callback SendAuthCommand\n * @param {Connection} connection The connection to write to\n * @param {Command} command A command with a toBin method that can be written to a connection\n * @param {AuthWriteCallback} callback Callback called when command response is received\n */\n\n/**\n * A callback for a specific auth command\n * @callback AuthWriteCallback\n * @param {Error} err If command failed, an error from the server\n * @param {object} r The response from the server\n */\n\n/**\n * This is a result from an authentication strategy\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {boolean} result The result of the authentication process\n */\n\n\nmodule.exports = {\n  AuthProvider\n};","map":{"version":3,"sources":["/home/hoangnd/source/ReactJS/todolist/node_modules/mongodb/lib/core/auth/auth_provider.js"],"names":["MongoError","require","AuthProvider","constructor","bson","authStore","auth","sendAuthCommand","connections","credentials","callback","count","length","numberOfValidConnections","errorObject","execute","connection","_authenticateSingleConnection","err","r","$err","errmsg","addCredentials","mechanism","executeInNextTick","_connection","process","nextTick","shift","Error","found","some","cred","equals","push","reauthenticate","slice","i","logout","source","filter","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst MongoError = require('../error').MongoError;\n\n/**\n * Creates a new AuthProvider, which dictates how to authenticate for a given\n * mechanism.\n * @class\n */\nclass AuthProvider {\n  constructor(bson) {\n    this.bson = bson;\n    this.authStore = [];\n  }\n\n  /**\n   * Authenticate\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {MongoCredentials} credentials Authentication credentials\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n  auth(sendAuthCommand, connections, credentials, callback) {\n    // Total connections\n    let count = connections.length;\n\n    if (count === 0) {\n      callback(null, null);\n      return;\n    }\n\n    // Valid connections\n    let numberOfValidConnections = 0;\n    let errorObject = null;\n\n    const execute = connection => {\n      this._authenticateSingleConnection(sendAuthCommand, connection, credentials, (err, r) => {\n        // Adjust count\n        count = count - 1;\n\n        // If we have an error\n        if (err) {\n          errorObject = new MongoError(err);\n        } else if (r && (r.$err || r.errmsg)) {\n          errorObject = new MongoError(r);\n        } else {\n          numberOfValidConnections = numberOfValidConnections + 1;\n        }\n\n        // Still authenticating against other connections.\n        if (count !== 0) {\n          return;\n        }\n\n        // We have authenticated all connections\n        if (numberOfValidConnections > 0) {\n          // Store the auth details\n          this.addCredentials(credentials);\n          // Return correct authentication\n          callback(null, true);\n        } else {\n          if (errorObject == null) {\n            errorObject = new MongoError(`failed to authenticate using ${credentials.mechanism}`);\n          }\n          callback(errorObject, false);\n        }\n      });\n    };\n\n    const executeInNextTick = _connection => process.nextTick(() => execute(_connection));\n\n    // For each connection we need to authenticate\n    while (connections.length > 0) {\n      executeInNextTick(connections.shift());\n    }\n  }\n\n  /**\n   * Implementation of a single connection authenticating. Is meant to be overridden.\n   * Will error if called directly\n   * @ignore\n   */\n  _authenticateSingleConnection(/*sendAuthCommand, connection, credentials, callback*/) {\n    throw new Error('_authenticateSingleConnection must be overridden');\n  }\n\n  /**\n   * Adds credentials to store only if it does not exist\n   * @param {MongoCredentials} credentials credentials to add to store\n   */\n  addCredentials(credentials) {\n    const found = this.authStore.some(cred => cred.equals(credentials));\n\n    if (!found) {\n      this.authStore.push(credentials);\n    }\n  }\n\n  /**\n   * Re authenticate pool\n   * @method\n   * @param {SendAuthCommand} sendAuthCommand Writes an auth command directly to a specific connection\n   * @param {Connection[]} connections Connections to authenticate using this authenticator\n   * @param {authResultCallback} callback The callback to return the result from the authentication\n   */\n  reauthenticate(sendAuthCommand, connections, callback) {\n    const authStore = this.authStore.slice(0);\n    let count = authStore.length;\n    if (count === 0) {\n      return callback(null, null);\n    }\n\n    for (let i = 0; i < authStore.length; i++) {\n      this.auth(sendAuthCommand, connections, authStore[i], function(err) {\n        count = count - 1;\n        if (count === 0) {\n          callback(err, null);\n        }\n      });\n    }\n  }\n\n  /**\n   * Remove credentials that have been previously stored in the auth provider\n   * @method\n   * @param {string} source Name of database we are removing authStore details about\n   * @return {object}\n   */\n  logout(source) {\n    this.authStore = this.authStore.filter(credentials => credentials.source !== source);\n  }\n}\n\n/**\n * A function that writes authentication commands to a specific connection\n * @callback SendAuthCommand\n * @param {Connection} connection The connection to write to\n * @param {Command} command A command with a toBin method that can be written to a connection\n * @param {AuthWriteCallback} callback Callback called when command response is received\n */\n\n/**\n * A callback for a specific auth command\n * @callback AuthWriteCallback\n * @param {Error} err If command failed, an error from the server\n * @param {object} r The response from the server\n */\n\n/**\n * This is a result from an authentication strategy\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {boolean} result The result of the authentication process\n */\n\nmodule.exports = { AuthProvider };\n"]},"metadata":{},"sourceType":"script"}