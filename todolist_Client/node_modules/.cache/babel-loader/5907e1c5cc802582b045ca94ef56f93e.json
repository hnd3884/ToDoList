{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst Connection = require('./connection');\n\nconst Query = require('./commands').Query;\n\nconst MongoError = require('../error').MongoError;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\n\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nconst makeClientMetadata = require('../utils').makeClientMetadata;\n\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\n\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n\n  const ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  const family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, (err, socket) => {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n\n      return;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction isModernConnectionType(conn) {\n  return typeof conn.command === 'function';\n}\n\nfunction getSaslSupportedMechs(options) {\n  if (!(options && options.credentials)) {\n    return {};\n  }\n\n  const credentials = options.credentials; // TODO: revisit whether or not items like `options.user` and `options.dbName` should be checked here\n\n  const authMechanism = credentials.mechanism;\n  const authSource = credentials.source || options.dbName || 'admin';\n  const user = credentials.username || options.user;\n\n  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') {\n    return {};\n  }\n\n  if (!user) {\n    return {};\n  }\n\n  return {\n    saslSupportedMechs: `${authSource}.${user}`\n  };\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === 'number' && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === 'number' && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n\n  const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  let compressors = [];\n\n  if (options.compression && options.compression.compressors) {\n    compressors = options.compression.compressors;\n  }\n\n  const handshakeDoc = Object.assign({\n    ismaster: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  }, getSaslSupportedMechs(options));\n  const handshakeOptions = Object.assign({}, options); // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n\n  if (options.connectTimeoutMS || options.connectionTimeout) {\n    handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n  }\n\n  const start = new Date().getTime();\n  runCommand(conn, 'admin.$cmd', handshakeDoc, handshakeOptions, (err, ismaster) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (ismaster.ok === 0) {\n      callback(new MongoError(ismaster));\n      return;\n    }\n\n    const supportedServerErr = checkSupportedServer(ismaster, options);\n\n    if (supportedServerErr) {\n      callback(supportedServerErr);\n      return;\n    }\n\n    if (!isModernConnectionType(conn)) {\n      // resolve compression\n      if (ismaster.compression) {\n        const agreedCompressors = compressors.filter(compressor => ismaster.compression.indexOf(compressor) !== -1);\n\n        if (agreedCompressors.length) {\n          conn.agreedCompressor = agreedCompressors[0];\n        }\n\n        if (options.compression && options.compression.zlibCompressionLevel) {\n          conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n        }\n      }\n    } // NOTE: This is metadata attached to the connection while porting away from\n    //       handshake being done in the `Server` class. Likely, it should be\n    //       relocated, or at very least restructured.\n\n\n    conn.ismaster = ismaster;\n    conn.lastIsMasterMS = new Date().getTime() - start;\n    const credentials = options.credentials;\n\n    if (!ismaster.arbiterOnly && credentials) {\n      credentials.resolveAuthMechanism(ismaster);\n      authenticate(conn, credentials, callback);\n      return;\n    }\n\n    callback(undefined, conn);\n  });\n}\n\nconst LEGAL_SSL_SOCKET_OPTIONS = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize', 'crl', 'rejectUnauthorized'];\n\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n\n  if (host.indexOf('/') !== -1) {\n    return {\n      path: host\n    };\n  }\n\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options); // Merge in valid SSL options\n\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  } // Override checkServerIdentity behavior\n\n\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function () {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\n\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n  const rejectUnauthorized = typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useSsl ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\n\nfunction runCommand(conn, ns, command, options, callback) {\n  if (typeof options === 'function') callback = options, options = {}; // are we using the new connection type? if so, no need to simulate a rpc `command` method\n\n  if (isModernConnectionType(conn)) {\n    conn.command(ns, command, options, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      } // NODE-2382: raw wire protocol messages, or command results should not be used anymore\n\n\n      callback(undefined, result.result);\n    });\n    return;\n  }\n\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n  const bson = conn.options.bson;\n  const query = new Query(bson, ns, command, {\n    numberToSkip: 0,\n    numberToReturn: 1\n  });\n\n  const noop = () => {};\n\n  function _callback(err, result) {\n    callback(err, result);\n    callback = noop;\n  }\n\n  function errorHandler(err) {\n    conn.resetSocketTimeout();\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n    conn.removeListener('message', messageHandler);\n\n    if (err == null) {\n      err = new MongoError(`runCommand failed for connection to '${conn.address}'`);\n    } // ignore all future errors\n\n\n    conn.on('error', noop);\n\n    _callback(err);\n  }\n\n  function messageHandler(msg) {\n    if (msg.responseTo !== query.requestId) {\n      return;\n    }\n\n    conn.resetSocketTimeout();\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n    conn.removeListener('message', messageHandler);\n    msg.parse({\n      promoteValues: true\n    });\n\n    _callback(undefined, msg.documents[0]);\n  }\n\n  conn.setSocketTimeout(socketTimeout);\n  CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n  conn.on('message', messageHandler);\n  conn.write(query.toBin());\n}\n\nfunction authenticate(conn, credentials, callback) {\n  const mechanism = credentials.mechanism;\n\n  if (!AUTH_PROVIDERS[mechanism]) {\n    callback(new MongoError(`authMechanism '${mechanism}' not supported`));\n    return;\n  }\n\n  const provider = AUTH_PROVIDERS[mechanism];\n  provider.auth(runCommand, [conn], credentials, err => {\n    if (err) return callback(err);\n    callback(undefined, conn);\n  });\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n\n    case 'timeout':\n      return new MongoNetworkError(`connection timed out`);\n\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n\n    case 'cancel':\n      return new MongoNetworkError(`connection establishment was cancelled`);\n\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\n\nmodule.exports = connect;","map":{"version":3,"sources":["/home/hoangnd/source/ReactJS/todolist/node_modules/mongodb/lib/core/connection/connect.js"],"names":["net","require","tls","Connection","Query","MongoError","MongoNetworkError","defaultAuthProviders","WIRE_CONSTANTS","makeClientMetadata","MAX_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MIN_SUPPORTED_SERVER_VERSION","AUTH_PROVIDERS","connect","options","cancellationToken","callback","undefined","ConnectionType","connectionType","bson","family","makeConnection","err","socket","performInitialHandshake","isModernConnectionType","conn","command","getSaslSupportedMechs","credentials","authMechanism","mechanism","authSource","source","dbName","user","username","toUpperCase","saslSupportedMechs","checkSupportedServer","ismaster","serverVersionHighEnough","maxWireVersion","serverVersionLowEnough","minWireVersion","message","host","port","_callback","ret","destroy","compressors","compression","handshakeDoc","Object","assign","client","metadata","handshakeOptions","connectTimeoutMS","connectionTimeout","socketTimeout","start","Date","getTime","runCommand","ok","supportedServerErr","agreedCompressors","filter","compressor","indexOf","length","agreedCompressor","zlibCompressionLevel","lastIsMasterMS","arbiterOnly","resolveAuthMechanism","authenticate","LEGAL_SSL_SOCKET_OPTIONS","parseConnectOptions","path","result","rejectUnauthorized","parseSslOptions","name","checkServerIdentity","servername","SOCKET_ERROR_EVENTS","Set","useSsl","ssl","keepAlive","keepAliveInitialDelay","noDelay","Math","round","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","removeListener","connectHandler","connectionFailureError","authorizationError","once","CONNECTION_ERROR_EVENTS","ns","query","numberToSkip","numberToReturn","noop","resetSocketTimeout","messageHandler","address","on","msg","responseTo","requestId","parse","promoteValues","documents","setSocketTimeout","write","toBin","provider","auth","type","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst net = require('net');\nconst tls = require('tls');\nconst Connection = require('./connection');\nconst Query = require('./commands').Query;\nconst MongoError = require('../error').MongoError;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\n\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n\n  const ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  const family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, (err, socket) => {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n      return;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction isModernConnectionType(conn) {\n  return typeof conn.command === 'function';\n}\n\nfunction getSaslSupportedMechs(options) {\n  if (!(options && options.credentials)) {\n    return {};\n  }\n\n  const credentials = options.credentials;\n\n  // TODO: revisit whether or not items like `options.user` and `options.dbName` should be checked here\n  const authMechanism = credentials.mechanism;\n  const authSource = credentials.source || options.dbName || 'admin';\n  const user = credentials.username || options.user;\n\n  if (typeof authMechanism === 'string' && authMechanism.toUpperCase() !== 'DEFAULT') {\n    return {};\n  }\n\n  if (!user) {\n    return {};\n  }\n\n  return { saslSupportedMechs: `${authSource}.${user}` };\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough =\n    ismaster &&\n    typeof ismaster.maxWireVersion === 'number' &&\n    ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    ismaster &&\n    typeof ismaster.minWireVersion === 'number' &&\n    ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n\n  const message = `Server at ${options.host}:${\n    options.port\n  } reports maximum wire version ${ismaster.maxWireVersion ||\n    0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function(err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n\n  let compressors = [];\n  if (options.compression && options.compression.compressors) {\n    compressors = options.compression.compressors;\n  }\n\n  const handshakeDoc = Object.assign(\n    {\n      ismaster: true,\n      client: options.metadata || makeClientMetadata(options),\n      compression: compressors\n    },\n    getSaslSupportedMechs(options)\n  );\n\n  const handshakeOptions = Object.assign({}, options);\n\n  // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n  if (options.connectTimeoutMS || options.connectionTimeout) {\n    handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n  }\n\n  const start = new Date().getTime();\n  runCommand(conn, 'admin.$cmd', handshakeDoc, handshakeOptions, (err, ismaster) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (ismaster.ok === 0) {\n      callback(new MongoError(ismaster));\n      return;\n    }\n\n    const supportedServerErr = checkSupportedServer(ismaster, options);\n    if (supportedServerErr) {\n      callback(supportedServerErr);\n      return;\n    }\n\n    if (!isModernConnectionType(conn)) {\n      // resolve compression\n      if (ismaster.compression) {\n        const agreedCompressors = compressors.filter(\n          compressor => ismaster.compression.indexOf(compressor) !== -1\n        );\n\n        if (agreedCompressors.length) {\n          conn.agreedCompressor = agreedCompressors[0];\n        }\n\n        if (options.compression && options.compression.zlibCompressionLevel) {\n          conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n        }\n      }\n    }\n\n    // NOTE: This is metadata attached to the connection while porting away from\n    //       handshake being done in the `Server` class. Likely, it should be\n    //       relocated, or at very least restructured.\n    conn.ismaster = ismaster;\n    conn.lastIsMasterMS = new Date().getTime() - start;\n\n    const credentials = options.credentials;\n    if (!ismaster.arbiterOnly && credentials) {\n      credentials.resolveAuthMechanism(ismaster);\n      authenticate(conn, credentials, callback);\n      return;\n    }\n\n    callback(undefined, conn);\n  });\n}\n\nconst LEGAL_SSL_SOCKET_OPTIONS = [\n  'pfx',\n  'key',\n  'passphrase',\n  'cert',\n  'ca',\n  'ciphers',\n  'NPNProtocols',\n  'ALPNProtocols',\n  'servername',\n  'ecdhCurve',\n  'secureProtocol',\n  'secureContext',\n  'session',\n  'minDHSize',\n  'crl',\n  'rejectUnauthorized'\n];\n\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n  if (host.indexOf('/') !== -1) {\n    return { path: host };\n  }\n\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options);\n\n  // Merge in valid SSL options\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  }\n\n  // Override checkServerIdentity behavior\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function() {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay =\n    typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout =\n    typeof options.connectionTimeout === 'number'\n      ? options.connectionTimeout\n      : typeof options.connectTimeoutMS === 'number'\n      ? options.connectTimeoutMS\n      : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n  const rejectUnauthorized =\n    typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  let socket;\n  const callback = function(err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n\n  const connectEvent = useSsl ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\nfunction runCommand(conn, ns, command, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n\n  // are we using the new connection type? if so, no need to simulate a rpc `command` method\n  if (isModernConnectionType(conn)) {\n    conn.command(ns, command, options, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      // NODE-2382: raw wire protocol messages, or command results should not be used anymore\n      callback(undefined, result.result);\n    });\n\n    return;\n  }\n\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n  const bson = conn.options.bson;\n  const query = new Query(bson, ns, command, {\n    numberToSkip: 0,\n    numberToReturn: 1\n  });\n\n  const noop = () => {};\n  function _callback(err, result) {\n    callback(err, result);\n    callback = noop;\n  }\n\n  function errorHandler(err) {\n    conn.resetSocketTimeout();\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n    conn.removeListener('message', messageHandler);\n\n    if (err == null) {\n      err = new MongoError(`runCommand failed for connection to '${conn.address}'`);\n    }\n\n    // ignore all future errors\n    conn.on('error', noop);\n\n    _callback(err);\n  }\n\n  function messageHandler(msg) {\n    if (msg.responseTo !== query.requestId) {\n      return;\n    }\n\n    conn.resetSocketTimeout();\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n    conn.removeListener('message', messageHandler);\n\n    msg.parse({ promoteValues: true });\n    _callback(undefined, msg.documents[0]);\n  }\n\n  conn.setSocketTimeout(socketTimeout);\n  CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n  conn.on('message', messageHandler);\n  conn.write(query.toBin());\n}\n\nfunction authenticate(conn, credentials, callback) {\n  const mechanism = credentials.mechanism;\n  if (!AUTH_PROVIDERS[mechanism]) {\n    callback(new MongoError(`authMechanism '${mechanism}' not supported`));\n    return;\n  }\n\n  const provider = AUTH_PROVIDERS[mechanism];\n  provider.auth(runCommand, [conn], credentials, err => {\n    if (err) return callback(err);\n    callback(undefined, conn);\n  });\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n    case 'timeout':\n      return new MongoNetworkError(`connection timed out`);\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n    case 'cancel':\n      return new MongoNetworkError(`connection establishment was cancelled`);\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\n\nmodule.exports = connect;\n"]},"metadata":{},"sourceType":"script"}