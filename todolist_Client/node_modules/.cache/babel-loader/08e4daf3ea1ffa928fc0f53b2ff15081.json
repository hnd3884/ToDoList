{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst EventEmitter = require('events');\n\nconst connect = require('../connection/connect');\n\nconst Connection = require('../../cmap/connection').Connection;\n\nconst common = require('./common');\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst MongoError = require('../error').MongoError;\n\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\n\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\nconst now = require('../../utils').now;\n\nconst sdamEvents = require('./events');\n\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    const addressParts = server.description.address.split(':');\n    this.connectOptions = Object.freeze(Object.assign({\n      id: '<monitor>',\n      host: addressParts[0],\n      port: parseInt(addressParts[1], 10),\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, this.options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }));\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    } // start\n\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId].wake();\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    this[kCancellationToken].emit('cancel');\n\n    if (this[kMonitorId]) {\n      this[kMonitorId].stop();\n      this[kMonitorId] = null;\n    }\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({\n        force: true\n      });\n    }\n\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n\n}\n\nfunction checkServer(monitor, callback) {\n  if (monitor[kConnection] && monitor[kConnection].closed) {\n    monitor[kConnection] = undefined;\n  }\n\n  const start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    callback(err);\n  }\n\n  function successHandler(isMaster) {\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), isMaster, monitor.address));\n    return callback(undefined, isMaster);\n  }\n\n  if (monitor[kConnection] != null) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    monitor[kConnection].command('admin.$cmd', {\n      ismaster: true\n    }, {\n      socketTimeout: connectTimeoutMS\n    }, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      successHandler(result.result);\n    });\n    return;\n  } // connecting does an implicit `ismaster`\n\n\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n      failureHandler(err);\n      return;\n    }\n\n    if (isInCloseState(monitor)) {\n      conn.destroy({\n        force: true\n      });\n      failureHandler(new MongoError('monitor was destroyed'));\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    successHandler(conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    } // TODO: the next line is a legacy event, remove in v4\n\n\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n    checkServer(monitor, e0 => {\n      if (e0 == null) {\n        return done();\n      } // otherwise an error occured on initial discovery, also bail\n\n\n      if (monitor[kServer].description.type === ServerType.Unknown) {\n        monitor.emit('resetServer', e0);\n        return done();\n      } // According to the SDAM specification's \"Network error during server check\" section, if\n      // an ismaster call fails we reset the server's pool. If a server was once connected,\n      // change its type to `Unknown` only after retrying once.\n\n\n      monitor.emit('resetConnectionPool');\n      checkServer(monitor, e1 => {\n        if (e1) {\n          monitor.emit('resetServer', e1);\n        }\n\n        done();\n      });\n    });\n  };\n}\n\nmodule.exports = {\n  Monitor\n};","map":{"version":3,"sources":["/home/hoangnd/source/ReactJS/todolist/node_modules/mongodb/lib/core/sdam/monitor.js"],"names":["ServerType","require","EventEmitter","connect","Connection","common","makeStateMachine","MongoError","makeInterruptableAsyncInterval","calculateDurationInMs","now","sdamEvents","ServerHeartbeatStartedEvent","ServerHeartbeatSucceededEvent","ServerHeartbeatFailedEvent","kServer","Symbol","kMonitorId","kConnection","kCancellationToken","STATE_CLOSED","STATE_CLOSING","STATE_IDLE","STATE_MONITORING","stateTransition","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","Monitor","constructor","server","options","undefined","setMaxListeners","Infinity","address","description","Object","freeze","connectTimeoutMS","connectionTimeout","heartbeatFrequencyMS","minHeartbeatFrequencyMS","addressParts","split","connectOptions","assign","id","host","port","parseInt","bson","connectionType","raw","promoteLongs","promoteValues","promoteBuffers","monitorServer","interval","minInterval","immediate","requestCheck","has","wake","close","emit","stop","destroy","force","checkServer","callback","closed","start","failureHandler","err","successHandler","isMaster","command","ismaster","socketTimeout","result","conn","done","process","nextTick","e0","type","Unknown","e1","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst ServerType = require('./common').ServerType;\nconst EventEmitter = require('events');\nconst connect = require('../connection/connect');\nconst Connection = require('../../cmap/connection').Connection;\nconst common = require('./common');\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst MongoError = require('../error').MongoError;\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\nconst now = require('../../utils').now;\n\nconst sdamEvents = require('./events');\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\n\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\n\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS:\n        typeof options.connectionTimeout === 'number'\n          ? options.connectionTimeout\n          : typeof options.connectTimeoutMS === 'number'\n          ? options.connectTimeoutMS\n          : 10000,\n      heartbeatFrequencyMS:\n        typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS:\n        typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    });\n\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const addressParts = server.description.address.split(':');\n    this.connectOptions = Object.freeze(\n      Object.assign(\n        {\n          id: '<monitor>',\n          host: addressParts[0],\n          port: parseInt(addressParts[1], 10),\n          bson: server.s.bson,\n          connectionType: Connection\n        },\n        server.s.options,\n        this.options,\n\n        // force BSON serialization options\n        {\n          raw: false,\n          promoteLongs: true,\n          promoteValues: true,\n          promoteBuffers: true\n        }\n      )\n    );\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId].wake();\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    this[kCancellationToken].emit('cancel');\n    if (this[kMonitorId]) {\n      this[kMonitorId].stop();\n      this[kMonitorId] = null;\n    }\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({ force: true });\n    }\n\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  if (monitor[kConnection] && monitor[kConnection].closed) {\n    monitor[kConnection] = undefined;\n  }\n\n  const start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    monitor.emit(\n      'serverHeartbeatFailed',\n      new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address)\n    );\n\n    callback(err);\n  }\n\n  function successHandler(isMaster) {\n    monitor.emit(\n      'serverHeartbeatSucceeded',\n      new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), isMaster, monitor.address)\n    );\n\n    return callback(undefined, isMaster);\n  }\n\n  if (monitor[kConnection] != null) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    monitor[kConnection].command(\n      'admin.$cmd',\n      { ismaster: true },\n      { socketTimeout: connectTimeoutMS },\n      (err, result) => {\n        if (err) {\n          failureHandler(err);\n          return;\n        }\n\n        successHandler(result.result);\n      }\n    );\n\n    return;\n  }\n\n  // connecting does an implicit `ismaster`\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (err) {\n      monitor[kConnection] = undefined;\n      failureHandler(err);\n      return;\n    }\n\n    if (isInCloseState(monitor)) {\n      conn.destroy({ force: true });\n      failureHandler(new MongoError('monitor was destroyed'));\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    successHandler(conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    // TODO: the next line is a legacy event, remove in v4\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n\n    checkServer(monitor, e0 => {\n      if (e0 == null) {\n        return done();\n      }\n\n      // otherwise an error occured on initial discovery, also bail\n      if (monitor[kServer].description.type === ServerType.Unknown) {\n        monitor.emit('resetServer', e0);\n        return done();\n      }\n\n      // According to the SDAM specification's \"Network error during server check\" section, if\n      // an ismaster call fails we reset the server's pool. If a server was once connected,\n      // change its type to `Unknown` only after retrying once.\n      monitor.emit('resetConnectionPool');\n\n      checkServer(monitor, e1 => {\n        if (e1) {\n          monitor.emit('resetServer', e1);\n        }\n\n        done();\n      });\n    });\n  };\n}\n\nmodule.exports = {\n  Monitor\n};\n"]},"metadata":{},"sourceType":"script"}