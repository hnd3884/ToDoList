{"ast":null,"code":"'use strict';\n\nconst Denque = require('denque');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Logger = require('../core/connection/logger');\n\nconst makeCounter = require('../utils').makeCounter;\n\nconst MongoError = require('../core/error').MongoError;\n\nconst Connection = require('./connection').Connection;\n\nconst eachAsync = require('../core/utils').eachAsync;\n\nconst connect = require('../core/connection/connect');\n\nconst relayEvents = require('../core/utils').relayEvents;\n\nconst errors = require('./errors');\n\nconst PoolClosedError = errors.PoolClosedError;\nconst WaitQueueTimeoutError = errors.WaitQueueTimeoutError;\n\nconst events = require('./events');\n\nconst ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;\nconst ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;\nconst ConnectionCreatedEvent = events.ConnectionCreatedEvent;\nconst ConnectionReadyEvent = events.ConnectionReadyEvent;\nconst ConnectionClosedEvent = events.ConnectionClosedEvent;\nconst ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;\nconst ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;\nconst ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;\nconst ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;\nconst ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;\nconst kLogger = Symbol('logger');\nconst kConnections = Symbol('connections');\nconst kPermits = Symbol('permits');\nconst kMinPoolSizeTimer = Symbol('minPoolSizeTimer');\nconst kGeneration = Symbol('generation');\nconst kConnectionCounter = Symbol('connectionCounter');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kWaitQueue = Symbol('waitQueue');\nconst kCancelled = Symbol('cancelled');\nconst VALID_POOL_OPTIONS = new Set([// `connect` options\n'ssl', 'bson', 'connectionType', 'monitorCommands', 'socketTimeout', 'credentials', 'compression', // node Net options\n'host', 'port', 'localAddress', 'localPort', 'family', 'hints', 'lookup', 'path', // node TLS options\n'ca', 'cert', 'sigalgs', 'ciphers', 'clientCertEngine', 'crl', 'dhparam', 'ecdhCurve', 'honorCipherOrder', 'key', 'privateKeyEngine', 'privateKeyIdentifier', 'maxVersion', 'minVersion', 'passphrase', 'pfx', 'secureOptions', 'secureProtocol', 'sessionIdContext', 'allowHalfOpen', 'rejectUnauthorized', 'pskCallback', 'ALPNProtocols', 'servername', 'checkServerIdentity', 'session', 'minDHSize', 'secureContext', // spec options\n'maxPoolSize', 'minPoolSize', 'maxIdleTimeMS', 'waitQueueTimeoutMS']);\n\nfunction resolveOptions(options, defaults) {\n  const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {\n    if (options.hasOwnProperty(key)) {\n      obj[key] = options[key];\n    }\n\n    return obj;\n  }, {});\n  return Object.freeze(Object.assign({}, defaults, newOptions));\n}\n/**\n * Configuration options for drivers wrapping the node driver.\n *\n * @typedef {Object} ConnectionPoolOptions\n * @property\n * @property {string} [host] The host to connect to\n * @property {number} [port] The port to connect to\n * @property {bson} [bson] The BSON instance to use for new connections\n * @property {number} [maxPoolSize=100] The maximum number of connections that may be associated with a pool at a given time. This includes in use and available connections.\n * @property {number} [minPoolSize=0] The minimum number of connections that MUST exist at any moment in a single connection pool.\n * @property {number} [maxIdleTimeMS] The maximum amount of time a connection should remain idle in the connection pool before being marked idle.\n * @property {number} [waitQueueTimeoutMS=0] The maximum amount of time operation execution should wait for a connection to become available. The default is 0 which means there is no limit.\n */\n\n/**\n * A pool of connections which dynamically resizes, and emit events related to pool activity\n *\n * @property {number} generation An integer representing the SDAM generation of the pool\n * @property {number} totalConnectionCount An integer expressing how many total connections (active + in use) the pool currently has\n * @property {number} availableConnectionCount An integer expressing how many connections are currently available in the pool.\n * @property {string} address The address of the endpoint the pool is connected to\n *\n * @emits ConnectionPool#connectionPoolCreated\n * @emits ConnectionPool#connectionPoolClosed\n * @emits ConnectionPool#connectionCreated\n * @emits ConnectionPool#connectionReady\n * @emits ConnectionPool#connectionClosed\n * @emits ConnectionPool#connectionCheckOutStarted\n * @emits ConnectionPool#connectionCheckOutFailed\n * @emits ConnectionPool#connectionCheckedOut\n * @emits ConnectionPool#connectionCheckedIn\n * @emits ConnectionPool#connectionPoolCleared\n */\n\n\nclass ConnectionPool extends EventEmitter {\n  /**\n   * Create a new Connection Pool\n   *\n   * @param {ConnectionPoolOptions} options\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n    this.closed = false;\n    this.options = resolveOptions(options, {\n      connectionType: Connection,\n      maxPoolSize: typeof options.maxPoolSize === 'number' ? options.maxPoolSize : 100,\n      minPoolSize: typeof options.minPoolSize === 'number' ? options.minPoolSize : 0,\n      maxIdleTimeMS: typeof options.maxIdleTimeMS === 'number' ? options.maxIdleTimeMS : 0,\n      waitQueueTimeoutMS: typeof options.waitQueueTimeoutMS === 'number' ? options.waitQueueTimeoutMS : 0,\n      autoEncrypter: options.autoEncrypter,\n      metadata: options.metadata\n    });\n\n    if (options.minSize > options.maxSize) {\n      throw new TypeError('Connection pool minimum size must not be greater than maxiumum pool size');\n    }\n\n    this[kLogger] = Logger('ConnectionPool', options);\n    this[kConnections] = new Denque();\n    this[kPermits] = this.options.maxPoolSize;\n    this[kMinPoolSizeTimer] = undefined;\n    this[kGeneration] = 0;\n    this[kConnectionCounter] = makeCounter(1);\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kWaitQueue] = new Denque();\n    process.nextTick(() => {\n      this.emit('connectionPoolCreated', new ConnectionPoolCreatedEvent(this));\n      ensureMinPoolSize(this);\n    });\n  }\n\n  get address() {\n    return `${this.options.host}:${this.options.port}`;\n  }\n\n  get generation() {\n    return this[kGeneration];\n  }\n\n  get totalConnectionCount() {\n    return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);\n  }\n\n  get availableConnectionCount() {\n    return this[kConnections].length;\n  }\n\n  get waitQueueSize() {\n    return this[kWaitQueue].length;\n  }\n  /**\n   * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it\n   * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or\n   * explicitly destroyed by the new owner.\n   *\n   * @param {ConnectionPool~checkOutCallback} callback\n   */\n\n\n  checkOut(callback) {\n    this.emit('connectionCheckOutStarted', new ConnectionCheckOutStartedEvent(this));\n\n    if (this.closed) {\n      this.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(this, 'poolClosed'));\n      callback(new PoolClosedError(this));\n      return;\n    } // add this request to the wait queue\n\n\n    const waitQueueMember = {\n      callback\n    };\n    const pool = this;\n    const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;\n\n    if (waitQueueTimeoutMS) {\n      waitQueueMember.timer = setTimeout(() => {\n        waitQueueMember[kCancelled] = true;\n        waitQueueMember.timer = undefined;\n        pool.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(pool, 'timeout'));\n        waitQueueMember.callback(new WaitQueueTimeoutError(pool));\n      }, waitQueueTimeoutMS);\n    } // place the member at the end of the wait queue\n\n\n    this[kWaitQueue].push(waitQueueMember); // process the wait queue\n\n    processWaitQueue(this);\n  }\n  /**\n   * Check a connection into the pool.\n   *\n   * @param {Connection} connection The connection to check in\n   */\n\n\n  checkIn(connection) {\n    const poolClosed = this.closed;\n    const stale = connectionIsStale(this, connection);\n    const willDestroy = !!(poolClosed || stale || connection.closed); // Properly adjust state of connection\n\n    if (!willDestroy) {\n      connection.markAvailable();\n      this[kConnections].push(connection);\n    }\n\n    this.emit('connectionCheckedIn', new ConnectionCheckedInEvent(this, connection));\n\n    if (willDestroy) {\n      const reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';\n      destroyConnection(this, connection, reason);\n    }\n\n    processWaitQueue(this);\n  }\n  /**\n   * Clear the pool\n   *\n   * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a\n   * previous generation will eventually be pruned during subsequent checkouts.\n   */\n\n\n  clear() {\n    this[kGeneration] += 1;\n    this.emit('connectionPoolCleared', new ConnectionPoolClearedEvent(this));\n  }\n  /**\n   * Close the pool\n   *\n   * @param {object} [options] Optional settings\n   * @param {boolean} [options.force] Force close connections\n   * @param {Function} callback\n   */\n\n\n  close(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this.closed) {\n      return callback();\n    } // immediately cancel any in-flight connections\n\n\n    this[kCancellationToken].emit('cancel'); // drain the wait queue\n\n    while (this.waitQueueSize) {\n      const waitQueueMember = this[kWaitQueue].pop();\n      clearTimeout(waitQueueMember.timer);\n\n      if (!waitQueueMember[kCancelled]) {\n        waitQueueMember.callback(new MongoError('connection pool closed'));\n      }\n    } // clear the min pool size timer\n\n\n    if (this[kMinPoolSizeTimer]) {\n      clearTimeout(this[kMinPoolSizeTimer]);\n    } // end the connection counter\n\n\n    if (typeof this[kConnectionCounter].return === 'function') {\n      this[kConnectionCounter].return();\n    } // mark the pool as closed immediately\n\n\n    this.closed = true;\n    eachAsync(this[kConnections].toArray(), (conn, cb) => {\n      this.emit('connectionClosed', new ConnectionClosedEvent(this, conn, 'poolClosed'));\n      conn.destroy(options, cb);\n    }, err => {\n      this[kConnections].clear();\n      this.emit('connectionPoolClosed', new ConnectionPoolClosedEvent(this));\n      callback(err);\n    });\n  }\n  /**\n   * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda\n   * has completed by calling back.\n   *\n   * NOTE: please note the required signature of `fn`\n   *\n   * @param {ConnectionPool~withConnectionCallback} fn A function which operates on a managed connection\n   * @param {Function} callback The original callback\n   * @return {Promise}\n   */\n\n\n  withConnection(fn, callback) {\n    this.checkOut((err, conn) => {\n      // don't callback with `err` here, we might want to act upon it inside `fn`\n      fn(err, conn, (fnErr, result) => {\n        if (typeof callback === 'function') {\n          if (fnErr) {\n            callback(fnErr);\n          } else {\n            callback(undefined, result);\n          }\n        }\n\n        if (conn) {\n          this.checkIn(conn);\n        }\n      });\n    });\n  }\n\n}\n\nfunction ensureMinPoolSize(pool) {\n  if (pool.closed || pool.options.minPoolSize === 0) {\n    return;\n  }\n\n  const minPoolSize = pool.options.minPoolSize;\n\n  for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {\n    createConnection(pool);\n  }\n\n  pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);\n}\n\nfunction connectionIsStale(pool, connection) {\n  return connection.generation !== pool[kGeneration];\n}\n\nfunction connectionIsIdle(pool, connection) {\n  return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);\n}\n\nfunction createConnection(pool, callback) {\n  const connectOptions = Object.assign({\n    id: pool[kConnectionCounter].next().value,\n    generation: pool[kGeneration]\n  }, pool.options);\n  pool[kPermits]--;\n  connect(connectOptions, pool[kCancellationToken], (err, connection) => {\n    if (err) {\n      pool[kPermits]++;\n      pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n\n      return;\n    } // The pool might have closed since we started trying to create a connection\n\n\n    if (pool.closed) {\n      connection.destroy({\n        force: true\n      });\n      return;\n    } // forward all events from the connection to the pool\n\n\n    relayEvents(connection, pool, ['commandStarted', 'commandFailed', 'commandSucceeded', 'clusterTimeReceived']);\n    pool.emit('connectionCreated', new ConnectionCreatedEvent(pool, connection));\n    connection.markAvailable();\n    pool.emit('connectionReady', new ConnectionReadyEvent(pool, connection)); // if a callback has been provided, check out the connection immediately\n\n    if (typeof callback === 'function') {\n      callback(undefined, connection);\n      return;\n    } // otherwise add it to the pool for later acquisition, and try to process the wait queue\n\n\n    pool[kConnections].push(connection);\n    processWaitQueue(pool);\n  });\n}\n\nfunction destroyConnection(pool, connection, reason) {\n  pool.emit('connectionClosed', new ConnectionClosedEvent(pool, connection, reason)); // allow more connections to be created\n\n  pool[kPermits]++; // destroy the connection\n\n  process.nextTick(() => connection.destroy());\n}\n\nfunction processWaitQueue(pool) {\n  if (pool.closed) {\n    return;\n  }\n\n  while (pool.waitQueueSize) {\n    const waitQueueMember = pool[kWaitQueue].peekFront();\n\n    if (waitQueueMember[kCancelled]) {\n      pool[kWaitQueue].shift();\n      continue;\n    }\n\n    if (!pool.availableConnectionCount) {\n      break;\n    }\n\n    const connection = pool[kConnections].shift();\n    const isStale = connectionIsStale(pool, connection);\n    const isIdle = connectionIsIdle(pool, connection);\n\n    if (!isStale && !isIdle && !connection.closed) {\n      pool.emit('connectionCheckedOut', new ConnectionCheckedOutEvent(pool, connection));\n      clearTimeout(waitQueueMember.timer);\n      pool[kWaitQueue].shift();\n      waitQueueMember.callback(undefined, connection);\n      return;\n    }\n\n    const reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';\n    destroyConnection(pool, connection, reason);\n  }\n\n  const maxPoolSize = pool.options.maxPoolSize;\n\n  if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {\n    createConnection(pool, (err, connection) => {\n      const waitQueueMember = pool[kWaitQueue].shift();\n\n      if (waitQueueMember == null) {\n        if (err == null) {\n          pool[kConnections].push(connection);\n        }\n\n        return;\n      }\n\n      if (waitQueueMember[kCancelled]) {\n        return;\n      }\n\n      if (err) {\n        pool.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(pool, err));\n      } else {\n        pool.emit('connectionCheckedOut', new ConnectionCheckedOutEvent(pool, connection));\n      }\n\n      clearTimeout(waitQueueMember.timer);\n      waitQueueMember.callback(err, connection);\n    });\n    return;\n  }\n}\n/**\n * A callback provided to `withConnection`\n *\n * @callback ConnectionPool~withConnectionCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Connection} connection The managed connection which was checked out of the pool.\n * @param {Function} callback A function to call back after connection management is complete\n */\n\n/**\n * A callback provided to `checkOut`\n *\n * @callback ConnectionPool~checkOutCallback\n * @param {MongoError} error An error instance representing the error during checkout\n * @param {Connection} connection A connection from the pool\n */\n\n/**\n * Emitted once when the connection pool is created\n *\n * @event ConnectionPool#connectionPoolCreated\n * @type {PoolCreatedEvent}\n */\n\n/**\n * Emitted once when the connection pool is closed\n *\n * @event ConnectionPool#connectionPoolClosed\n * @type {PoolClosedEvent}\n */\n\n/**\n * Emitted each time a connection is created\n *\n * @event ConnectionPool#connectionCreated\n * @type {ConnectionCreatedEvent}\n */\n\n/**\n * Emitted when a connection becomes established, and is ready to use\n *\n * @event ConnectionPool#connectionReady\n * @type {ConnectionReadyEvent}\n */\n\n/**\n * Emitted when a connection is closed\n *\n * @event ConnectionPool#connectionClosed\n * @type {ConnectionClosedEvent}\n */\n\n/**\n * Emitted when an attempt to check out a connection begins\n *\n * @event ConnectionPool#connectionCheckOutStarted\n * @type {ConnectionCheckOutStartedEvent}\n */\n\n/**\n * Emitted when an attempt to check out a connection fails\n *\n * @event ConnectionPool#connectionCheckOutFailed\n * @type {ConnectionCheckOutFailedEvent}\n */\n\n/**\n * Emitted each time a connection is successfully checked out of the connection pool\n *\n * @event ConnectionPool#connectionCheckedOut\n * @type {ConnectionCheckedOutEvent}\n */\n\n/**\n * Emitted each time a connection is successfully checked into the connection pool\n *\n * @event ConnectionPool#connectionCheckedIn\n * @type {ConnectionCheckedInEvent}\n */\n\n/**\n * Emitted each time the connection pool is cleared and it's generation incremented\n *\n * @event ConnectionPool#connectionPoolCleared\n * @type {PoolClearedEvent}\n */\n\n\nmodule.exports = {\n  ConnectionPool\n};","map":{"version":3,"sources":["/home/hoangnd/source/ReactJS/todolist/node_modules/mongodb/lib/cmap/connection_pool.js"],"names":["Denque","require","EventEmitter","Logger","makeCounter","MongoError","Connection","eachAsync","connect","relayEvents","errors","PoolClosedError","WaitQueueTimeoutError","events","ConnectionPoolCreatedEvent","ConnectionPoolClosedEvent","ConnectionCreatedEvent","ConnectionReadyEvent","ConnectionClosedEvent","ConnectionCheckOutStartedEvent","ConnectionCheckOutFailedEvent","ConnectionCheckedOutEvent","ConnectionCheckedInEvent","ConnectionPoolClearedEvent","kLogger","Symbol","kConnections","kPermits","kMinPoolSizeTimer","kGeneration","kConnectionCounter","kCancellationToken","kWaitQueue","kCancelled","VALID_POOL_OPTIONS","Set","resolveOptions","options","defaults","newOptions","Array","from","reduce","obj","key","hasOwnProperty","Object","freeze","assign","ConnectionPool","constructor","closed","connectionType","maxPoolSize","minPoolSize","maxIdleTimeMS","waitQueueTimeoutMS","autoEncrypter","metadata","minSize","maxSize","TypeError","undefined","setMaxListeners","Infinity","process","nextTick","emit","ensureMinPoolSize","address","host","port","generation","totalConnectionCount","length","availableConnectionCount","waitQueueSize","checkOut","callback","waitQueueMember","pool","timer","setTimeout","push","processWaitQueue","checkIn","connection","poolClosed","stale","connectionIsStale","willDestroy","markAvailable","reason","destroyConnection","clear","close","force","pop","clearTimeout","return","toArray","conn","cb","destroy","err","withConnection","fn","fnErr","result","i","createConnection","connectionIsIdle","idleTime","connectOptions","id","next","value","debug","JSON","stringify","peekFront","shift","isStale","isIdle","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Denque = require('denque');\nconst EventEmitter = require('events').EventEmitter;\nconst Logger = require('../core/connection/logger');\nconst makeCounter = require('../utils').makeCounter;\nconst MongoError = require('../core/error').MongoError;\nconst Connection = require('./connection').Connection;\nconst eachAsync = require('../core/utils').eachAsync;\nconst connect = require('../core/connection/connect');\nconst relayEvents = require('../core/utils').relayEvents;\n\nconst errors = require('./errors');\nconst PoolClosedError = errors.PoolClosedError;\nconst WaitQueueTimeoutError = errors.WaitQueueTimeoutError;\n\nconst events = require('./events');\nconst ConnectionPoolCreatedEvent = events.ConnectionPoolCreatedEvent;\nconst ConnectionPoolClosedEvent = events.ConnectionPoolClosedEvent;\nconst ConnectionCreatedEvent = events.ConnectionCreatedEvent;\nconst ConnectionReadyEvent = events.ConnectionReadyEvent;\nconst ConnectionClosedEvent = events.ConnectionClosedEvent;\nconst ConnectionCheckOutStartedEvent = events.ConnectionCheckOutStartedEvent;\nconst ConnectionCheckOutFailedEvent = events.ConnectionCheckOutFailedEvent;\nconst ConnectionCheckedOutEvent = events.ConnectionCheckedOutEvent;\nconst ConnectionCheckedInEvent = events.ConnectionCheckedInEvent;\nconst ConnectionPoolClearedEvent = events.ConnectionPoolClearedEvent;\n\nconst kLogger = Symbol('logger');\nconst kConnections = Symbol('connections');\nconst kPermits = Symbol('permits');\nconst kMinPoolSizeTimer = Symbol('minPoolSizeTimer');\nconst kGeneration = Symbol('generation');\nconst kConnectionCounter = Symbol('connectionCounter');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kWaitQueue = Symbol('waitQueue');\nconst kCancelled = Symbol('cancelled');\n\nconst VALID_POOL_OPTIONS = new Set([\n  // `connect` options\n  'ssl',\n  'bson',\n  'connectionType',\n  'monitorCommands',\n  'socketTimeout',\n  'credentials',\n  'compression',\n\n  // node Net options\n  'host',\n  'port',\n  'localAddress',\n  'localPort',\n  'family',\n  'hints',\n  'lookup',\n  'path',\n\n  // node TLS options\n  'ca',\n  'cert',\n  'sigalgs',\n  'ciphers',\n  'clientCertEngine',\n  'crl',\n  'dhparam',\n  'ecdhCurve',\n  'honorCipherOrder',\n  'key',\n  'privateKeyEngine',\n  'privateKeyIdentifier',\n  'maxVersion',\n  'minVersion',\n  'passphrase',\n  'pfx',\n  'secureOptions',\n  'secureProtocol',\n  'sessionIdContext',\n  'allowHalfOpen',\n  'rejectUnauthorized',\n  'pskCallback',\n  'ALPNProtocols',\n  'servername',\n  'checkServerIdentity',\n  'session',\n  'minDHSize',\n  'secureContext',\n\n  // spec options\n  'maxPoolSize',\n  'minPoolSize',\n  'maxIdleTimeMS',\n  'waitQueueTimeoutMS'\n]);\n\nfunction resolveOptions(options, defaults) {\n  const newOptions = Array.from(VALID_POOL_OPTIONS).reduce((obj, key) => {\n    if (options.hasOwnProperty(key)) {\n      obj[key] = options[key];\n    }\n\n    return obj;\n  }, {});\n\n  return Object.freeze(Object.assign({}, defaults, newOptions));\n}\n\n/**\n * Configuration options for drivers wrapping the node driver.\n *\n * @typedef {Object} ConnectionPoolOptions\n * @property\n * @property {string} [host] The host to connect to\n * @property {number} [port] The port to connect to\n * @property {bson} [bson] The BSON instance to use for new connections\n * @property {number} [maxPoolSize=100] The maximum number of connections that may be associated with a pool at a given time. This includes in use and available connections.\n * @property {number} [minPoolSize=0] The minimum number of connections that MUST exist at any moment in a single connection pool.\n * @property {number} [maxIdleTimeMS] The maximum amount of time a connection should remain idle in the connection pool before being marked idle.\n * @property {number} [waitQueueTimeoutMS=0] The maximum amount of time operation execution should wait for a connection to become available. The default is 0 which means there is no limit.\n */\n\n/**\n * A pool of connections which dynamically resizes, and emit events related to pool activity\n *\n * @property {number} generation An integer representing the SDAM generation of the pool\n * @property {number} totalConnectionCount An integer expressing how many total connections (active + in use) the pool currently has\n * @property {number} availableConnectionCount An integer expressing how many connections are currently available in the pool.\n * @property {string} address The address of the endpoint the pool is connected to\n *\n * @emits ConnectionPool#connectionPoolCreated\n * @emits ConnectionPool#connectionPoolClosed\n * @emits ConnectionPool#connectionCreated\n * @emits ConnectionPool#connectionReady\n * @emits ConnectionPool#connectionClosed\n * @emits ConnectionPool#connectionCheckOutStarted\n * @emits ConnectionPool#connectionCheckOutFailed\n * @emits ConnectionPool#connectionCheckedOut\n * @emits ConnectionPool#connectionCheckedIn\n * @emits ConnectionPool#connectionPoolCleared\n */\nclass ConnectionPool extends EventEmitter {\n  /**\n   * Create a new Connection Pool\n   *\n   * @param {ConnectionPoolOptions} options\n   */\n  constructor(options) {\n    super();\n    options = options || {};\n\n    this.closed = false;\n    this.options = resolveOptions(options, {\n      connectionType: Connection,\n      maxPoolSize: typeof options.maxPoolSize === 'number' ? options.maxPoolSize : 100,\n      minPoolSize: typeof options.minPoolSize === 'number' ? options.minPoolSize : 0,\n      maxIdleTimeMS: typeof options.maxIdleTimeMS === 'number' ? options.maxIdleTimeMS : 0,\n      waitQueueTimeoutMS:\n        typeof options.waitQueueTimeoutMS === 'number' ? options.waitQueueTimeoutMS : 0,\n      autoEncrypter: options.autoEncrypter,\n      metadata: options.metadata\n    });\n\n    if (options.minSize > options.maxSize) {\n      throw new TypeError(\n        'Connection pool minimum size must not be greater than maxiumum pool size'\n      );\n    }\n\n    this[kLogger] = Logger('ConnectionPool', options);\n    this[kConnections] = new Denque();\n    this[kPermits] = this.options.maxPoolSize;\n    this[kMinPoolSizeTimer] = undefined;\n    this[kGeneration] = 0;\n    this[kConnectionCounter] = makeCounter(1);\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kWaitQueue] = new Denque();\n\n    process.nextTick(() => {\n      this.emit('connectionPoolCreated', new ConnectionPoolCreatedEvent(this));\n      ensureMinPoolSize(this);\n    });\n  }\n\n  get address() {\n    return `${this.options.host}:${this.options.port}`;\n  }\n\n  get generation() {\n    return this[kGeneration];\n  }\n\n  get totalConnectionCount() {\n    return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);\n  }\n\n  get availableConnectionCount() {\n    return this[kConnections].length;\n  }\n\n  get waitQueueSize() {\n    return this[kWaitQueue].length;\n  }\n\n  /**\n   * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it\n   * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or\n   * explicitly destroyed by the new owner.\n   *\n   * @param {ConnectionPool~checkOutCallback} callback\n   */\n  checkOut(callback) {\n    this.emit('connectionCheckOutStarted', new ConnectionCheckOutStartedEvent(this));\n\n    if (this.closed) {\n      this.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(this, 'poolClosed'));\n      callback(new PoolClosedError(this));\n      return;\n    }\n\n    // add this request to the wait queue\n    const waitQueueMember = { callback };\n\n    const pool = this;\n    const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;\n    if (waitQueueTimeoutMS) {\n      waitQueueMember.timer = setTimeout(() => {\n        waitQueueMember[kCancelled] = true;\n        waitQueueMember.timer = undefined;\n\n        pool.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(pool, 'timeout'));\n        waitQueueMember.callback(new WaitQueueTimeoutError(pool));\n      }, waitQueueTimeoutMS);\n    }\n\n    // place the member at the end of the wait queue\n    this[kWaitQueue].push(waitQueueMember);\n\n    // process the wait queue\n    processWaitQueue(this);\n  }\n\n  /**\n   * Check a connection into the pool.\n   *\n   * @param {Connection} connection The connection to check in\n   */\n  checkIn(connection) {\n    const poolClosed = this.closed;\n    const stale = connectionIsStale(this, connection);\n    const willDestroy = !!(poolClosed || stale || connection.closed);\n\n    // Properly adjust state of connection\n    if (!willDestroy) {\n      connection.markAvailable();\n\n      this[kConnections].push(connection);\n    }\n\n    this.emit('connectionCheckedIn', new ConnectionCheckedInEvent(this, connection));\n\n    if (willDestroy) {\n      const reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';\n      destroyConnection(this, connection, reason);\n    }\n\n    processWaitQueue(this);\n  }\n\n  /**\n   * Clear the pool\n   *\n   * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a\n   * previous generation will eventually be pruned during subsequent checkouts.\n   */\n  clear() {\n    this[kGeneration] += 1;\n    this.emit('connectionPoolCleared', new ConnectionPoolClearedEvent(this));\n  }\n\n  /**\n   * Close the pool\n   *\n   * @param {object} [options] Optional settings\n   * @param {boolean} [options.force] Force close connections\n   * @param {Function} callback\n   */\n  close(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this.closed) {\n      return callback();\n    }\n\n    // immediately cancel any in-flight connections\n    this[kCancellationToken].emit('cancel');\n\n    // drain the wait queue\n    while (this.waitQueueSize) {\n      const waitQueueMember = this[kWaitQueue].pop();\n      clearTimeout(waitQueueMember.timer);\n      if (!waitQueueMember[kCancelled]) {\n        waitQueueMember.callback(new MongoError('connection pool closed'));\n      }\n    }\n\n    // clear the min pool size timer\n    if (this[kMinPoolSizeTimer]) {\n      clearTimeout(this[kMinPoolSizeTimer]);\n    }\n\n    // end the connection counter\n    if (typeof this[kConnectionCounter].return === 'function') {\n      this[kConnectionCounter].return();\n    }\n\n    // mark the pool as closed immediately\n    this.closed = true;\n\n    eachAsync(\n      this[kConnections].toArray(),\n      (conn, cb) => {\n        this.emit('connectionClosed', new ConnectionClosedEvent(this, conn, 'poolClosed'));\n        conn.destroy(options, cb);\n      },\n      err => {\n        this[kConnections].clear();\n        this.emit('connectionPoolClosed', new ConnectionPoolClosedEvent(this));\n        callback(err);\n      }\n    );\n  }\n\n  /**\n   * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda\n   * has completed by calling back.\n   *\n   * NOTE: please note the required signature of `fn`\n   *\n   * @param {ConnectionPool~withConnectionCallback} fn A function which operates on a managed connection\n   * @param {Function} callback The original callback\n   * @return {Promise}\n   */\n  withConnection(fn, callback) {\n    this.checkOut((err, conn) => {\n      // don't callback with `err` here, we might want to act upon it inside `fn`\n\n      fn(err, conn, (fnErr, result) => {\n        if (typeof callback === 'function') {\n          if (fnErr) {\n            callback(fnErr);\n          } else {\n            callback(undefined, result);\n          }\n        }\n\n        if (conn) {\n          this.checkIn(conn);\n        }\n      });\n    });\n  }\n}\n\nfunction ensureMinPoolSize(pool) {\n  if (pool.closed || pool.options.minPoolSize === 0) {\n    return;\n  }\n\n  const minPoolSize = pool.options.minPoolSize;\n  for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {\n    createConnection(pool);\n  }\n\n  pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);\n}\n\nfunction connectionIsStale(pool, connection) {\n  return connection.generation !== pool[kGeneration];\n}\n\nfunction connectionIsIdle(pool, connection) {\n  return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);\n}\n\nfunction createConnection(pool, callback) {\n  const connectOptions = Object.assign(\n    {\n      id: pool[kConnectionCounter].next().value,\n      generation: pool[kGeneration]\n    },\n    pool.options\n  );\n\n  pool[kPermits]--;\n  connect(connectOptions, pool[kCancellationToken], (err, connection) => {\n    if (err) {\n      pool[kPermits]++;\n      pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n\n      return;\n    }\n\n    // The pool might have closed since we started trying to create a connection\n    if (pool.closed) {\n      connection.destroy({ force: true });\n      return;\n    }\n\n    // forward all events from the connection to the pool\n    relayEvents(connection, pool, [\n      'commandStarted',\n      'commandFailed',\n      'commandSucceeded',\n      'clusterTimeReceived'\n    ]);\n\n    pool.emit('connectionCreated', new ConnectionCreatedEvent(pool, connection));\n\n    connection.markAvailable();\n    pool.emit('connectionReady', new ConnectionReadyEvent(pool, connection));\n\n    // if a callback has been provided, check out the connection immediately\n    if (typeof callback === 'function') {\n      callback(undefined, connection);\n      return;\n    }\n\n    // otherwise add it to the pool for later acquisition, and try to process the wait queue\n    pool[kConnections].push(connection);\n    processWaitQueue(pool);\n  });\n}\n\nfunction destroyConnection(pool, connection, reason) {\n  pool.emit('connectionClosed', new ConnectionClosedEvent(pool, connection, reason));\n\n  // allow more connections to be created\n  pool[kPermits]++;\n\n  // destroy the connection\n  process.nextTick(() => connection.destroy());\n}\n\nfunction processWaitQueue(pool) {\n  if (pool.closed) {\n    return;\n  }\n\n  while (pool.waitQueueSize) {\n    const waitQueueMember = pool[kWaitQueue].peekFront();\n    if (waitQueueMember[kCancelled]) {\n      pool[kWaitQueue].shift();\n      continue;\n    }\n\n    if (!pool.availableConnectionCount) {\n      break;\n    }\n\n    const connection = pool[kConnections].shift();\n    const isStale = connectionIsStale(pool, connection);\n    const isIdle = connectionIsIdle(pool, connection);\n    if (!isStale && !isIdle && !connection.closed) {\n      pool.emit('connectionCheckedOut', new ConnectionCheckedOutEvent(pool, connection));\n      clearTimeout(waitQueueMember.timer);\n      pool[kWaitQueue].shift();\n      waitQueueMember.callback(undefined, connection);\n      return;\n    }\n\n    const reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';\n    destroyConnection(pool, connection, reason);\n  }\n\n  const maxPoolSize = pool.options.maxPoolSize;\n  if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {\n    createConnection(pool, (err, connection) => {\n      const waitQueueMember = pool[kWaitQueue].shift();\n      if (waitQueueMember == null) {\n        if (err == null) {\n          pool[kConnections].push(connection);\n        }\n\n        return;\n      }\n\n      if (waitQueueMember[kCancelled]) {\n        return;\n      }\n\n      if (err) {\n        pool.emit('connectionCheckOutFailed', new ConnectionCheckOutFailedEvent(pool, err));\n      } else {\n        pool.emit('connectionCheckedOut', new ConnectionCheckedOutEvent(pool, connection));\n      }\n\n      clearTimeout(waitQueueMember.timer);\n      waitQueueMember.callback(err, connection);\n    });\n\n    return;\n  }\n}\n\n/**\n * A callback provided to `withConnection`\n *\n * @callback ConnectionPool~withConnectionCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Connection} connection The managed connection which was checked out of the pool.\n * @param {Function} callback A function to call back after connection management is complete\n */\n\n/**\n * A callback provided to `checkOut`\n *\n * @callback ConnectionPool~checkOutCallback\n * @param {MongoError} error An error instance representing the error during checkout\n * @param {Connection} connection A connection from the pool\n */\n\n/**\n * Emitted once when the connection pool is created\n *\n * @event ConnectionPool#connectionPoolCreated\n * @type {PoolCreatedEvent}\n */\n\n/**\n * Emitted once when the connection pool is closed\n *\n * @event ConnectionPool#connectionPoolClosed\n * @type {PoolClosedEvent}\n */\n\n/**\n * Emitted each time a connection is created\n *\n * @event ConnectionPool#connectionCreated\n * @type {ConnectionCreatedEvent}\n */\n\n/**\n * Emitted when a connection becomes established, and is ready to use\n *\n * @event ConnectionPool#connectionReady\n * @type {ConnectionReadyEvent}\n */\n\n/**\n * Emitted when a connection is closed\n *\n * @event ConnectionPool#connectionClosed\n * @type {ConnectionClosedEvent}\n */\n\n/**\n * Emitted when an attempt to check out a connection begins\n *\n * @event ConnectionPool#connectionCheckOutStarted\n * @type {ConnectionCheckOutStartedEvent}\n */\n\n/**\n * Emitted when an attempt to check out a connection fails\n *\n * @event ConnectionPool#connectionCheckOutFailed\n * @type {ConnectionCheckOutFailedEvent}\n */\n\n/**\n * Emitted each time a connection is successfully checked out of the connection pool\n *\n * @event ConnectionPool#connectionCheckedOut\n * @type {ConnectionCheckedOutEvent}\n */\n\n/**\n * Emitted each time a connection is successfully checked into the connection pool\n *\n * @event ConnectionPool#connectionCheckedIn\n * @type {ConnectionCheckedInEvent}\n */\n\n/**\n * Emitted each time the connection pool is cleared and it's generation incremented\n *\n * @event ConnectionPool#connectionPoolCleared\n * @type {PoolClearedEvent}\n */\n\nmodule.exports = {\n  ConnectionPool\n};\n"]},"metadata":{},"sourceType":"script"}