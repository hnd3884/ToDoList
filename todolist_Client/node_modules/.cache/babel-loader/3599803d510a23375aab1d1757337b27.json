{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\n\nconst MongoError = require('../error').MongoError;\n\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nlet saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nvar parsePayload = function (payload) {\n  var dict = {};\n  var parts = payload.split(',');\n\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n};\n\nvar passwordDigest = function (username, password) {\n  if (typeof username !== 'string') throw new MongoError('username must be a string');\n  if (typeof password !== 'string') throw new MongoError('password must be a string');\n  if (password.length === 0) throw new MongoError('password cannot be empty'); // Use node md5 generator\n\n  var md5 = crypto.createHash('md5'); // Generate keys used for authentication\n\n  md5.update(username + ':mongo:' + password, 'utf8');\n  return md5.digest('hex');\n}; // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\n\nvar _hiCachePurge = function () {\n  _hiCache = {};\n  _hiCacheCount = 0;\n};\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n/**\n * Creates a new ScramSHA authentication mechanism\n * @class\n * @extends AuthProvider\n */\n\n\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  static _getError(err, r) {\n    if (err) {\n      return err;\n    }\n\n    if (r.$err || r.errmsg) {\n      return new MongoError(r);\n    }\n  }\n  /**\n   * @ignore\n   */\n\n\n  _executeScram(sendAuthCommand, connection, credentials, nonce, callback) {\n    let username = credentials.username;\n    const password = credentials.password;\n    const db = credentials.source;\n    const cryptoMethod = this.cryptoMethod;\n    let mechanism = 'SCRAM-SHA-1';\n    let processedPassword;\n\n    if (cryptoMethod === 'sha256') {\n      mechanism = 'SCRAM-SHA-256';\n      processedPassword = saslprep ? saslprep(password) : password;\n    } else {\n      try {\n        processedPassword = passwordDigest(username, password);\n      } catch (e) {\n        return callback(e);\n      }\n    } // Clean up the user\n\n\n    username = username.replace('=', '=3D').replace(',', '=2C'); // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n\n    const firstBare = Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce, 'utf8')]); // Build command structure\n\n    const saslStartCmd = {\n      saslStart: 1,\n      mechanism,\n      payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),\n      autoAuthorize: 1\n    }; // Write the commmand on the connection\n\n    sendAuthCommand(connection, `${db}.$cmd`, saslStartCmd, (err, r) => {\n      let tmpError = ScramSHA._getError(err, r);\n\n      if (tmpError) {\n        return callback(tmpError, null);\n      }\n\n      const payload = Buffer.isBuffer(r.payload) ? new Binary(r.payload) : r.payload;\n      const dict = parsePayload(payload.value());\n      const iterations = parseInt(dict.i, 10);\n\n      if (iterations && iterations < 4096) {\n        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n        return;\n      }\n\n      const salt = dict.s;\n      const rnonce = dict.r;\n\n      if (rnonce.startsWith('nonce')) {\n        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n        return;\n      } // Set up start of proof\n\n\n      const withoutProof = `c=biws,r=${rnonce}`;\n      const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n      const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n      const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n      const storedKey = H(cryptoMethod, clientKey);\n      const authMessage = [firstBare, payload.value().toString('base64'), withoutProof].join(',');\n      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n      const clientProof = `p=${xor(clientKey, clientSignature)}`;\n      const clientFinal = [withoutProof, clientProof].join(',');\n      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n      const saslContinueCmd = {\n        saslContinue: 1,\n        conversationId: r.conversationId,\n        payload: new Binary(Buffer.from(clientFinal))\n      };\n      sendAuthCommand(connection, `${db}.$cmd`, saslContinueCmd, (err, r) => {\n        if (err || r && typeof r.ok === 'number' && r.ok === 0) {\n          callback(err, r);\n          return;\n        }\n\n        const parsedResponse = parsePayload(r.payload.value());\n\n        if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n          callback(new MongoError('Server returned an invalid signature'));\n          return;\n        }\n\n        if (!r || r.done !== false) {\n          return callback(err, r);\n        }\n\n        const retrySaslContinueCmd = {\n          saslContinue: 1,\n          conversationId: r.conversationId,\n          payload: Buffer.alloc(0)\n        };\n        sendAuthCommand(connection, `${db}.$cmd`, retrySaslContinueCmd, callback);\n      });\n    });\n  }\n  /**\n   * Implementation of authentication for a single connection\n   * @override\n   */\n\n\n  _authenticateSingleConnection(sendAuthCommand, connection, credentials, callback) {\n    // Create a random nonce\n    crypto.randomBytes(24, (err, buff) => {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return this._executeScram(sendAuthCommand, connection, credentials, buff.toString('base64'), callback);\n    });\n  }\n  /**\n   * Authenticate\n   * @override\n   * @method\n   */\n\n\n  auth(sendAuthCommand, connections, credentials, callback) {\n    this._checkSaslprep();\n\n    super.auth(sendAuthCommand, connections, credentials, callback);\n  }\n\n  _checkSaslprep() {\n    const cryptoMethod = this.cryptoMethod;\n\n    if (cryptoMethod === 'sha256') {\n      if (!saslprep) {\n        console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n      }\n    }\n  }\n\n}\n/**\n * Creates a new ScramSHA1 authentication mechanism\n * @class\n * @extends ScramSHA\n */\n\n\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n\n}\n/**\n * Creates a new ScramSHA256 authentication mechanism\n * @class\n * @extends ScramSHA\n */\n\n\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n\n}\n\nmodule.exports = {\n  ScramSHA1,\n  ScramSHA256\n};","map":{"version":3,"sources":["/home/hoangnd/source/ReactJS/todolist/node_modules/mongodb/lib/core/auth/scram.js"],"names":["crypto","require","Buffer","retrieveBSON","MongoError","AuthProvider","BSON","Binary","saslprep","e","parsePayload","payload","dict","parts","split","i","length","valueParts","passwordDigest","username","password","md5","createHash","update","digest","xor","a","b","isBuffer","from","Math","max","res","push","toString","H","method","text","HMAC","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","HI","data","salt","iterations","cryptoMethod","join","undefined","saltedData","pbkdf2Sync","compareDigest","lhs","rhs","timingSafeEqual","result","ScramSHA","constructor","bson","_getError","err","r","$err","errmsg","_executeScram","sendAuthCommand","connection","credentials","nonce","callback","db","source","mechanism","processedPassword","replace","firstBare","concat","saslStartCmd","saslStart","autoAuthorize","tmpError","value","parseInt","s","rnonce","startsWith","withoutProof","saltedPassword","clientKey","serverKey","storedKey","authMessage","clientSignature","clientProof","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","ok","parsedResponse","v","done","retrySaslContinueCmd","alloc","_authenticateSingleConnection","randomBytes","buff","auth","connections","_checkSaslprep","console","warn","ScramSHA1","ScramSHA256","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst crypto = require('crypto');\nconst Buffer = require('safe-buffer').Buffer;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst MongoError = require('../error').MongoError;\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\n\nlet saslprep;\ntry {\n  saslprep = require('saslprep');\n} catch (e) {\n  // don't do anything;\n}\n\nvar parsePayload = function(payload) {\n  var dict = {};\n  var parts = payload.split(',');\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n};\n\nvar passwordDigest = function(username, password) {\n  if (typeof username !== 'string') throw new MongoError('username must be a string');\n  if (typeof password !== 'string') throw new MongoError('password must be a string');\n  if (password.length === 0) throw new MongoError('password cannot be empty');\n  // Use node md5 generator\n  var md5 = crypto.createHash('md5');\n  // Generate keys used for authentication\n  md5.update(username + ':mongo:' + password, 'utf8');\n  return md5.digest('hex');\n};\n\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) a = Buffer.from(a);\n  if (!Buffer.isBuffer(b)) b = Buffer.from(b);\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto\n    .createHash(method)\n    .update(text)\n    .digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto\n    .createHmac(method, key)\n    .update(text)\n    .digest();\n}\n\nvar _hiCache = {};\nvar _hiCacheCount = 0;\nvar _hiCachePurge = function() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n};\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\n/**\n * Creates a new ScramSHA authentication mechanism\n * @class\n * @extends AuthProvider\n */\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  static _getError(err, r) {\n    if (err) {\n      return err;\n    }\n\n    if (r.$err || r.errmsg) {\n      return new MongoError(r);\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _executeScram(sendAuthCommand, connection, credentials, nonce, callback) {\n    let username = credentials.username;\n    const password = credentials.password;\n    const db = credentials.source;\n\n    const cryptoMethod = this.cryptoMethod;\n    let mechanism = 'SCRAM-SHA-1';\n    let processedPassword;\n\n    if (cryptoMethod === 'sha256') {\n      mechanism = 'SCRAM-SHA-256';\n\n      processedPassword = saslprep ? saslprep(password) : password;\n    } else {\n      try {\n        processedPassword = passwordDigest(username, password);\n      } catch (e) {\n        return callback(e);\n      }\n    }\n\n    // Clean up the user\n    username = username.replace('=', '=3D').replace(',', '=2C');\n\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    const firstBare = Buffer.concat([\n      Buffer.from('n=', 'utf8'),\n      Buffer.from(username, 'utf8'),\n      Buffer.from(',r=', 'utf8'),\n      Buffer.from(nonce, 'utf8')\n    ]);\n\n    // Build command structure\n    const saslStartCmd = {\n      saslStart: 1,\n      mechanism,\n      payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), firstBare])),\n      autoAuthorize: 1\n    };\n\n    // Write the commmand on the connection\n    sendAuthCommand(connection, `${db}.$cmd`, saslStartCmd, (err, r) => {\n      let tmpError = ScramSHA._getError(err, r);\n      if (tmpError) {\n        return callback(tmpError, null);\n      }\n\n      const payload = Buffer.isBuffer(r.payload) ? new Binary(r.payload) : r.payload;\n      const dict = parsePayload(payload.value());\n\n      const iterations = parseInt(dict.i, 10);\n      if (iterations && iterations < 4096) {\n        callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n        return;\n      }\n\n      const salt = dict.s;\n      const rnonce = dict.r;\n      if (rnonce.startsWith('nonce')) {\n        callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n        return;\n      }\n\n      // Set up start of proof\n      const withoutProof = `c=biws,r=${rnonce}`;\n      const saltedPassword = HI(\n        processedPassword,\n        Buffer.from(salt, 'base64'),\n        iterations,\n        cryptoMethod\n      );\n\n      const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n      const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n      const storedKey = H(cryptoMethod, clientKey);\n      const authMessage = [firstBare, payload.value().toString('base64'), withoutProof].join(',');\n\n      const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n      const clientProof = `p=${xor(clientKey, clientSignature)}`;\n      const clientFinal = [withoutProof, clientProof].join(',');\n\n      const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n\n      const saslContinueCmd = {\n        saslContinue: 1,\n        conversationId: r.conversationId,\n        payload: new Binary(Buffer.from(clientFinal))\n      };\n\n      sendAuthCommand(connection, `${db}.$cmd`, saslContinueCmd, (err, r) => {\n        if (err || (r && typeof r.ok === 'number' && r.ok === 0)) {\n          callback(err, r);\n          return;\n        }\n\n        const parsedResponse = parsePayload(r.payload.value());\n        if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n          callback(new MongoError('Server returned an invalid signature'));\n          return;\n        }\n\n        if (!r || r.done !== false) {\n          return callback(err, r);\n        }\n\n        const retrySaslContinueCmd = {\n          saslContinue: 1,\n          conversationId: r.conversationId,\n          payload: Buffer.alloc(0)\n        };\n\n        sendAuthCommand(connection, `${db}.$cmd`, retrySaslContinueCmd, callback);\n      });\n    });\n  }\n\n  /**\n   * Implementation of authentication for a single connection\n   * @override\n   */\n  _authenticateSingleConnection(sendAuthCommand, connection, credentials, callback) {\n    // Create a random nonce\n    crypto.randomBytes(24, (err, buff) => {\n      if (err) {\n        return callback(err, null);\n      }\n\n      return this._executeScram(\n        sendAuthCommand,\n        connection,\n        credentials,\n        buff.toString('base64'),\n        callback\n      );\n    });\n  }\n\n  /**\n   * Authenticate\n   * @override\n   * @method\n   */\n  auth(sendAuthCommand, connections, credentials, callback) {\n    this._checkSaslprep();\n    super.auth(sendAuthCommand, connections, credentials, callback);\n  }\n\n  _checkSaslprep() {\n    const cryptoMethod = this.cryptoMethod;\n\n    if (cryptoMethod === 'sha256') {\n      if (!saslprep) {\n        console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n      }\n    }\n  }\n}\n\n/**\n * Creates a new ScramSHA1 authentication mechanism\n * @class\n * @extends ScramSHA\n */\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n}\n\n/**\n * Creates a new ScramSHA256 authentication mechanism\n * @class\n * @extends ScramSHA\n */\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n}\n\nmodule.exports = { ScramSHA1, ScramSHA256 };\n"]},"metadata":{},"sourceType":"script"}