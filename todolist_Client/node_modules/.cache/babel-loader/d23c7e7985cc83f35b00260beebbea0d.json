{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst crypto = require('crypto');\n\nconst debugOptions = require('./utils').debugOptions;\n\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\n\nconst decompress = require('../wireprotocol/compression').decompress;\n\nconst Response = require('./commands').Response;\n\nconst BinMsg = require('./msg').BinMsg;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MongoError = require('../error').MongoError;\n\nconst Logger = require('./logger');\n\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\n\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst Buffer = require('safe-buffer').Buffer;\n\nlet _id = 0;\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\n\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n    options = options || {};\n\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000; // These values are inspected directly in tests, but maybe not necessary to keep around\n\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n    this.connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    } // Debug information\n\n\n    if (this.logger.isDebug()) {\n      this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options))}]`);\n    } // Response options\n\n\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    }; // Flushing\n\n    this.flushing = false;\n    this.queue = []; // Internal state\n\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false; // Create hash method\n\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex'); // All operations in flight on the connection\n\n    this.workItems = []; // setup socket\n\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   */\n\n\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n\n\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n  /**\n   * Destroy connection\n   * @method\n   */\n\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n\n\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++) this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\n      }\n    } // Double check that the connection is not destroyed\n\n\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      } // Iterate over all buffers and write them in order to the socket\n\n\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    } // Connection is destroyed return write failed\n\n\n    return false;\n  }\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n\n\n  toString() {\n    return '' + this.id;\n  }\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n\n\n  toJSON() {\n    return {\n      id: this.id,\n      host: this.host,\n      port: this.port\n    };\n  }\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n\n\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n\n}\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n} //\n// Connection handlers\n\n\nfunction errorHandler(conn) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(conn.id); // Debug information\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function () {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.timedOut = true;\n    conn.emit('timeout', new MongoNetworkError(`connection ${conn.id} to ${conn.address} timed out`), conn);\n  };\n}\n\nfunction closeHandler(conn) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit('close', new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);\n    }\n  };\n} // Handle a message once it is received\n\n\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit('error', new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);\n  });\n}\n\nfunction dataHandler(conn) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          conn.bytesRead = conn.bytesRead + data.length; // Reset state of buffer\n\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          const emitBuffer = conn.buffer; // Reset state of buffer\n\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            conn.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, conn.stubBuffer.length); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {\n              conn.buffer = Buffer.alloc(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(conn.buffer, 0); // Update bytes read\n\n              conn.bytesRead = data.length; // Update sizeOfMessage\n\n              conn.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {\n              const emitBuffer = data; // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0); // Emit the message\n\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn); // Clear out the state of the parser\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length); // Copy the data to the stub buffer\n\n            data.copy(conn.stubBuffer, 0); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\n\nmodule.exports = Connection;","map":{"version":3,"sources":["/home/hoangnd/source/ReactJS/todolist/node_modules/mongodb/lib/core/connection/connection.js"],"names":["EventEmitter","require","crypto","debugOptions","parseHeader","decompress","Response","BinMsg","MongoNetworkError","MongoError","Logger","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","Buffer","_id","DEFAULT_MAX_BSON_MESSAGE_SIZE","DEBUG_FIELDS","connectionAccountingSpy","undefined","connectionAccounting","connections","Connection","constructor","socket","options","bson","TypeError","id","logger","tag","maxBsonMessageSize","port","host","socketTimeout","keepAlive","keepAliveInitialDelay","connectionTimeout","Math","round","isDebug","debug","JSON","stringify","responseOptions","promoteLongs","promoteValues","promoteBuffers","flushing","queue","writeStream","destroyed","timedOut","hash","createHash","update","address","hashedName","digest","workItems","once","errorHandler","timeoutHandler","closeHandler","on","dataHandler","addConnection","setSocketTimeout","value","setTimeout","resetSocketTimeout","enableConnectionAccounting","spy","disableConnectionAccounting","unref","flush","err","length","workItem","shift","cb","destroy","callback","Object","assign","force","deleteConnection","end","write","buffer","Array","isArray","toString","i","toJSON","isConnected","writable","connection","conn","emit","hadError","processMessage","message","msgHeader","opCode","ResponseConstructor","slice","fromCompressed","index","readInt32LE","compressorID","decompressedMsgBody","data","bytesRead","sizeOfMessage","remainingBytesToRead","copy","alloc","emitBuffer","stubBuffer","newData","newStubBuffer","errorObject","trace","bin","parseState","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst crypto = require('crypto');\nconst debugOptions = require('./utils').debugOptions;\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\nconst decompress = require('../wireprotocol/compression').decompress;\nconst Response = require('./commands').Response;\nconst BinMsg = require('./msg').BinMsg;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoError = require('../error').MongoError;\nconst Logger = require('./logger');\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst Buffer = require('safe-buffer').Buffer;\n\nlet _id = 0;\n\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = [\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'checkServerIdentity'\n];\n\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n\n    options = options || {};\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n\n    // These values are inspected directly in tests, but maybe not necessary to keep around\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay =\n      typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 300000;\n    this.connectionTimeout =\n      typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    }\n\n    // Debug information\n    if (this.logger.isDebug()) {\n      this.logger.debug(\n        `creating connection ${this.id} with options [${JSON.stringify(\n          debugOptions(DEBUG_FIELDS, options)\n        )}]`\n      );\n    }\n\n    // Response options\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    };\n\n    // Flushing\n    this.flushing = false;\n    this.queue = [];\n\n    // Internal state\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false;\n\n    // Create hash method\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex');\n\n    // All operations in flight on the connection\n    this.workItems = [];\n\n    // setup socket\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   */\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n\n  /**\n   * Destroy connection\n   * @method\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++)\n          this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\n      }\n    }\n\n    // Double check that the connection is not destroyed\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      }\n\n      // Iterate over all buffers and write them in order to the socket\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    }\n\n    // Connection is destroyed return write failed\n    return false;\n  }\n\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n  toString() {\n    return '' + this.id;\n  }\n\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n  toJSON() {\n    return { id: this.id, host: this.host, port: this.port };\n  }\n\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n}\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n}\n\n//\n// Connection handlers\nfunction errorHandler(conn) {\n  return function(err) {\n    if (connectionAccounting) deleteConnection(conn.id);\n    // Debug information\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\n        `connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`\n      );\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function() {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.timedOut = true;\n    conn.emit(\n      'timeout',\n      new MongoNetworkError(`connection ${conn.id} to ${conn.address} timed out`),\n      conn\n    );\n  };\n}\n\nfunction closeHandler(conn) {\n  return function(hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit(\n        'close',\n        new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`),\n        conn\n      );\n    }\n  };\n}\n\n// Handle a message once it is received\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        message.slice(MESSAGE_HEADER_SIZE),\n        conn.responseOptions\n      ),\n      conn\n    );\n\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit(\n        'error',\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        decompressedMsgBody,\n        conn.responseOptions\n      ),\n      conn\n    );\n  });\n}\n\nfunction dataHandler(conn) {\n  return function(data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          conn.bytesRead = conn.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          const emitBuffer = conn.buffer;\n          // Reset state of buffer\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            conn.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, conn.stubBuffer.length);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n            // If we have a negative sizeOfMessage emit error and return\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage > data.length\n            ) {\n              conn.buffer = Buffer.alloc(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(conn.buffer, 0);\n              // Update bytes read\n              conn.bytesRead = data.length;\n              // Update sizeOfMessage\n              conn.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage === data.length\n            ) {\n              const emitBuffer = data;\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n\n              // Clear out the state of the parser\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length);\n            // Copy the data to the stub buffer\n            data.copy(conn.stubBuffer, 0);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\nmodule.exports = Connection;\n"]},"metadata":{},"sourceType":"script"}