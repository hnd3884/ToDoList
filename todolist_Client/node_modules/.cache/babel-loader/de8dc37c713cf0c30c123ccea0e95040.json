{"ast":null,"code":"'use strict';\n\nconst MongoError = require('./core/error').MongoError;\n\nconst ReadPreference = require('./core/topologies/read_preference');\n\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function (obj) {\n  var copy = {};\n\n  for (var name in obj) copy[name] = obj[name];\n\n  return copy;\n}; // Figure out the read preference\n\n\nvar translateReadPreference = function (options) {\n  var r = null;\n\n  if (options.readPreference) {\n    r = options.readPreference;\n  } else {\n    return options;\n  }\n\n  if (typeof r === 'string') {\n    options.readPreference = new ReadPreference(r);\n  } else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {\n    const mode = r.mode || r.preference;\n\n    if (mode && typeof mode === 'string') {\n      options.readPreference = new ReadPreference(mode, r.tags, {\n        maxStalenessSeconds: r.maxStalenessSeconds\n      });\n    }\n  } else if (!(r instanceof ReadPreference)) {\n    throw new TypeError('Invalid read preference: ' + r);\n  }\n\n  return options;\n}; // Set simple property\n\n\nvar getSingleProperty = function (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = exports.formatSortValue = function (sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], \" + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function (sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue === 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function (callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\n\n\nvar toError = function (error) {\n  if (error instanceof Error) return error;\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({\n    message: msg,\n    driver: true\n  }); // Get all object keys\n\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {// continue\n    }\n  }\n\n  return e;\n};\n/**\n * @ignore\n */\n\n\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\n\n\nvar parseIndexOptions = function (fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys; // Get all the fields accordingly\n\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function (f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function (key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n};\n\nvar debugOptions = function (debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function (n) {\n    finaloptions[n] = options[n];\n  });\n  return finaloptions;\n};\n\nvar decorateCommand = function (command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function (target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n}; // Merge options with translation\n\n\nvar translateOptions = function (target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function (options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  } // Filtered options\n\n\n  return filterOptions;\n}; // Write concern keys\n\n\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync']; // Merge the write concern options\n\nvar mergeOptionsAndWriteConcern = function (targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for (var i = 0; i < keys.length; i++) {\n    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  } // No merging of write concern\n\n\n  if (!mergeWriteConcern) return targetOptions; // Found no write Concern options\n\n  var found = false;\n\n  for (i = 0; i < writeConcernKeys.length; i++) {\n    if (targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (i = 0; i < writeConcernKeys.length; i++) {\n      if (sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n};\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\n\n\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1]; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, opOptions, owner;\n\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {\n    if (session && session.owner === owner && !options.returnsCursor) {\n      session.endSession(() => {\n        delete opOptions.session;\n        if (err) return reject(err);\n        resolve(result);\n      });\n    } else {\n      if (err) return reject(err);\n      resolve(result);\n    }\n  }; // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(null, result), err => callback(err, null));\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  } // Return a Promise\n\n\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function (resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\n\n\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\n\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n/**\n * Resolves a read preference based on well-defined inheritance rules. This method will not only\n * determine the read preference (if there is one), but will also ensure the returned value is a\n * properly constructed instance of `ReadPreference`.\n *\n * @param {Collection|Db|MongoClient} parent The parent of the operation on which to determine the read\n * preference, used for determining the inherited read preference.\n * @param {Object} options The options passed into the method, potentially containing a read preference\n * @returns {(ReadPreference|null)} The resolved read preference\n */\n\n\nfunction resolveReadPreference(parent, options) {\n  options = options || {};\n  const session = options.session;\n  const inheritedReadPreference = parent.readPreference;\n  let readPreference;\n\n  if (options.readPreference) {\n    readPreference = ReadPreference.fromOptions(options);\n  } else if (session && session.inTransaction() && session.transaction.options.readPreference) {\n    // The transaction’s read preference MUST override all other user configurable read preferences.\n    readPreference = session.transaction.options.readPreference;\n  } else if (inheritedReadPreference != null) {\n    readPreference = inheritedReadPreference;\n  } else {\n    throw new Error('No readPreference was provided or inherited.');\n  }\n\n  return typeof readPreference === 'string' ? new ReadPreference(readPreference) : readPreference;\n}\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\n\n\nfunction decorateWithCollation(command, target, options) {\n  const topology = target.s && target.s.topology || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\n\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  let readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nconst emitProcessWarning = msg => process.emitWarning(msg, 'DeprecationWarning');\n\nconst emitConsoleWarning = msg => console.error(msg);\n\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\n\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated() {\n    const options = arguments[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (options.hasOwnProperty(deprecatedOption) && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n    return fn.apply(this, arguments);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {}; // Test asyncIterator support\n\ntry {\n  require('./async/async_iterator');\n\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\n\n\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function (err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    }\n\n    callback(err, res);\n  });\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\n\n\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n\n  function wake() {\n    const currentTime = now();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = Math.max(interval - timeSinceLastCall, 0);\n    lastWakeTime = currentTime; // debounce multiple calls to wake within the `minInterval`\n\n    if (timeSinceLastWake < minInterval) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = now();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = now();\n    reschedule();\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  mergeOptionsAndWriteConcern,\n  translateReadPreference,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  resolveReadPreference,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval\n};","map":{"version":3,"sources":["/home/hoangnd/source/ReactJS/todolist/node_modules/mongodb/lib/utils.js"],"names":["MongoError","require","ReadPreference","WriteConcern","shallowClone","obj","copy","name","translateReadPreference","options","r","readPreference","mode","preference","tags","maxStalenessSeconds","TypeError","getSingleProperty","value","Object","defineProperty","enumerable","get","formatSortValue","exports","sortDirection","toLowerCase","Error","formattedOrderClause","sortValue","orderBy","Array","isArray","length","i","constructor","String","checkCollectionName","collectionName","indexOf","match","handleCallback","callback","err","value1","value2","process","nextTick","toError","error","msg","errmsg","errMessage","e","create","message","driver","keys","normalizeHintField","hint","finalHint","forEach","param","parseIndexOptions","fieldOrSpec","fieldHash","indexes","push","f","isObject","k","key","join","arg","prototype","toString","call","debugOptions","debugFields","finaloptions","n","decorateCommand","command","exclude","mergeOptions","target","source","translateOptions","translations","sslCA","sslCRL","sslValidate","sslKey","sslCert","sslPass","socketTimeoutMS","connectTimeoutMS","replicaSet","rs_name","secondaryAcceptableLatencyMS","connectWithNoPrimary","acceptableLatencyMS","filterOptions","names","writeConcernKeys","mergeOptionsAndWriteConcern","targetOptions","sourceOptions","mergeWriteConcern","undefined","found","executeLegacyOperation","topology","operation","args","Promise","s","promiseLibrary","session","opOptions","owner","skipSessions","hasSessionSupport","Symbol","startSession","optionsIndex","assign","hasEnded","makeExecuteCallback","resolve","reject","executeCallback","result","returnsCursor","endSession","pop","handler","apply","applyRetryableWrites","db","retryWrites","applyWriteConcern","sources","coll","collection","inTransaction","writeConcern","fromOptions","resolveReadPreference","parent","inheritedReadPreference","transaction","isPromiseLike","maybePromise","then","decorateWithCollation","capabilities","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","emitProcessWarning","emitWarning","emitConsoleWarning","console","emitDeprecationWarning","defaultMsgHandler","option","deprecateOptions","config","fn","noDeprecation","msgHandler","optionsWarned","Set","deprecated","arguments","deprecatedOptions","deprecatedOption","hasOwnProperty","has","add","getLogger","logger","warn","setPrototypeOf","SUPPORTS","ASYNC_ITERATOR","MongoDBNamespace","withCollection","fromString","namespace","index","substring","makeCounter","seed","count","newCount","PromiseLibrary","res","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","makeInterruptableAsyncInterval","timerId","lastCallTime","lastWakeTime","stopped","interval","minInterval","immediate","wake","currentTime","timeSinceLastWake","timeSinceLastCall","timeUntilNextCall","max","reschedule","stop","clearTimeout","ms","setTimeout","executeAndReschedule","module","MAX_JS_INT","Number","MAX_SAFE_INTEGER"],"mappings":"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","sourcesContent":["'use strict';\nconst MongoError = require('./core/error').MongoError;\nconst ReadPreference = require('./core/topologies/read_preference');\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function(obj) {\n  var copy = {};\n  for (var name in obj) copy[name] = obj[name];\n  return copy;\n};\n\n// Figure out the read preference\nvar translateReadPreference = function(options) {\n  var r = null;\n  if (options.readPreference) {\n    r = options.readPreference;\n  } else {\n    return options;\n  }\n\n  if (typeof r === 'string') {\n    options.readPreference = new ReadPreference(r);\n  } else if (r && !(r instanceof ReadPreference) && typeof r === 'object') {\n    const mode = r.mode || r.preference;\n    if (mode && typeof mode === 'string') {\n      options.readPreference = new ReadPreference(mode, r.tags, {\n        maxStalenessSeconds: r.maxStalenessSeconds\n      });\n    }\n  } else if (!(r instanceof ReadPreference)) {\n    throw new TypeError('Invalid read preference: ' + r);\n  }\n\n  return options;\n};\n\n// Set simple property\nvar getSingleProperty = function(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function() {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = (exports.formatSortValue = function(sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new Error(\n        'Illegal sort clause, must be of the form ' +\n          \"[['field1', '(ascending|descending)'], \" +\n          \"['field2', '(ascending|descending)']]\"\n      );\n  }\n});\n\nvar formattedOrderClause = (exports.formattedOrderClause = function(sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue === 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error(\n      'Illegal sort clause, must be of the form ' +\n        \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\"\n    );\n  }\n\n  return orderBy;\n});\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (\n    collectionName.indexOf('$') !== -1 &&\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\n  ) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function(callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function() {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\nvar toError = function(error) {\n  if (error instanceof Error) return error;\n\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({ message: msg, driver: true });\n\n  // Get all object keys\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {\n      // continue\n    }\n  }\n\n  return e;\n};\n\n/**\n * @ignore\n */\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(function(param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\nvar parseIndexOptions = function(fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys;\n\n  // Get all the fields accordingly\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function(f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function(k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function(key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = (exports.isObject = function(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n});\n\nvar debugOptions = function(debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function(n) {\n    finaloptions[n] = options[n];\n  });\n\n  return finaloptions;\n};\n\nvar decorateCommand = function(command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function(target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n};\n\n// Merge options with translation\nvar translateOptions = function(target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function(options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  }\n\n  // Filtered options\n  return filterOptions;\n};\n\n// Write concern keys\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync'];\n\n// Merge the write concern options\nvar mergeOptionsAndWriteConcern = function(targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for (var i = 0; i < keys.length; i++) {\n    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  }\n\n  // No merging of write concern\n  if (!mergeWriteConcern) return targetOptions;\n\n  // Found no write Concern options\n  var found = false;\n  for (i = 0; i < writeConcernKeys.length; i++) {\n    if (targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (i = 0; i < writeConcernKeys.length; i++) {\n      if (sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n};\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1];\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session, opOptions, owner;\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({ owner });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) =>\n    function executeCallback(err, result) {\n      if (session && session.owner === owner && !options.returnsCursor) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n\n  // Execute using callback\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(\n      result => callback(null, result),\n      err => callback(err, null)\n    );\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n\n  // Return a Promise\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function(resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, { writeConcern });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n  }\n\n  return target;\n}\n\n/**\n * Resolves a read preference based on well-defined inheritance rules. This method will not only\n * determine the read preference (if there is one), but will also ensure the returned value is a\n * properly constructed instance of `ReadPreference`.\n *\n * @param {Collection|Db|MongoClient} parent The parent of the operation on which to determine the read\n * preference, used for determining the inherited read preference.\n * @param {Object} options The options passed into the method, potentially containing a read preference\n * @returns {(ReadPreference|null)} The resolved read preference\n */\nfunction resolveReadPreference(parent, options) {\n  options = options || {};\n  const session = options.session;\n\n  const inheritedReadPreference = parent.readPreference;\n\n  let readPreference;\n  if (options.readPreference) {\n    readPreference = ReadPreference.fromOptions(options);\n  } else if (session && session.inTransaction() && session.transaction.options.readPreference) {\n    // The transaction’s read preference MUST override all other user configurable read preferences.\n    readPreference = session.transaction.options.readPreference;\n  } else if (inheritedReadPreference != null) {\n    readPreference = inheritedReadPreference;\n  } else {\n    throw new Error('No readPreference was provided or inherited.');\n  }\n\n  return typeof readPreference === 'string' ? new ReadPreference(readPreference) : readPreference;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n  const topology = (target.s && target.s.topology) || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  let readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n}\n\nconst emitProcessWarning = msg => process.emitWarning(msg, 'DeprecationWarning');\nconst emitConsoleWarning = msg => console.error(msg);\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n\n  const optionsWarned = new Set();\n  function deprecated() {\n    const options = arguments[config.optionsIndex];\n\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (options.hasOwnProperty(deprecatedOption) && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n\n    return fn.apply(this, arguments);\n  }\n\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {};\n// Test asyncIterator support\ntry {\n  require('./async/async_iterator');\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = (parent && parent.s && parent.s.promiseLibrary) || Promise;\n\n  let result;\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function(err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n      return;\n    }\n\n    callback(err, res);\n  });\n\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n\n  function wake() {\n    const currentTime = now();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = Math.max(interval - timeSinceLastCall, 0);\n    lastWakeTime = currentTime;\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (timeSinceLastWake < minInterval) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n  }\n\n  function stop() {\n    stopped = true;\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = now();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = now();\n    reschedule();\n  }\n\n  return { wake, stop };\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  mergeOptionsAndWriteConcern,\n  translateReadPreference,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  resolveReadPreference,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval\n};\n"]},"metadata":{},"sourceType":"script"}